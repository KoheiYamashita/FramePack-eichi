# FramePack-eichi

FramePack-eichi 是基於 lllyasviel 老師的 lllyasviel/FramePack 的分支，以及 nirvash 先生的 nirvash/FramePack 為基礎，所創建的附加功能版本。基於 nirvash 先生的先驅性改進，搭載了許多細節功能。

![FramePack-eichi畫面1](images/framepack_eichi_screenshot1.png)

## 📘 名稱的由來

**Endframe Image CHain Interface (EICHI)**
- **E**ndframe: 強化和最佳化終端幀功能
- **I**mage: 改善關鍵幀圖像處理和視覺回饋
- **CH**ain: 複數的關鍵幀間的連接和關係的強化
- **I**nterface: 直感性的使用者體驗和 UI/UX 的提升

「eichi」是日本語的「睿智」（深刻的智慧、英知）的表達，代表著 AI 技術的進化和人間創造性的的融合，象征著本專案的哲學。
即叡智的差分幀從動畫製作中專案的現地改修仕別。

## 🌟 主要功能

- **高品質動畫生成**: 由單張圖片產生自然動畫　※既存功能
- **多幀鍵幀對應**: 設定多幀鍵幀產生複雜動畫　※nirvash 氏追加功能
- **靈活的影片長度設定**：支援1〜4秒的短時間模式和6〜20秒的長時間模式 ※獨有功能（v1.5.1新增1秒模式，v1.6.1新增2〜4秒模式）
- **MP4壓縮設定**：可調整影片檔案大小與品質的平衡 ※v1.6.2從主分支合併
- **【試驗實作】所有邊距功能**: 所有區段使用同一邊距值　※v1.4添加
- **【試驗實作】幀尺寸設定**: 0.5秒模式和1秒模式可切換　※v1.5添加
- **【試驗實作】區段特別提示設定**: 可為各區段設定個別提示詞　※v1.2添加
- **【調査中】Hunyuan LoRA支持**: 模型自訂獨特表現　※v1.3添加
- **【v1.7新功能】紅框/藍框關鍵幀圖像高效複製**：僅需 2 個關鍵幀即可覆蓋所有區段
- **輸出文件管理功能**: 指定輸出文件夾　※v1.2添加
- **プロンプ特管理機能**: 儲存、編輯、再使用プロンプ特　※v1.3添加
- **日誌功能**: 詳細的進度信息和完成時的處理時間　※獨自功能
- **跨平台支持**: Windows以外的環境也能使用基本功能　※應該可以

![FramePack-eichi畫面2](images/framepack_eichi_screenshot2.png)

## 📝 最新更新資訊 (v1.7.1)

### 重大更新

#### 1. 內部運算最佳化
- **改進了 0.5 秒模式的處理**：分段數的計算現在更加精確，提高了視訊產生的穩定性。

#### 2. 使用者介面改進
- **簡化影片模式顯示**：刪除了影片模式名稱中多餘的括號（例如：「10(5x2) 秒」→「10 秒」）
- **佈局組織**：整個使用者介面已進行組織，更易於使用

### 終點及鍵幀圖像持續性問題（待處理）

部分使用者報告以下問題，目前待處理：

- 如果停止生成，然後再重新開始，可能無法使用端點和關鍵影格影像
- 刪除並再重新上傳影像可解決此問題，但在開始產生前很難發現此問題
- 如果發現此問題，請關閉影像並重新上傳一次
- 在 v1.5.1，系統已經過審查，並實作在按下開始按鈕時明確地重新獲取影像

### Hunyuan LoRA對應情況

暫定對應狀態：

- v1.6 LoRA適用邏輯統一，高 VRAM 模式和低 VRAM 模式使用同一直接應用方式
- VRAM管理基準值變更（60GB→100GB），更多用戶低 VRAM 模式運作可能
- 使用需 VRAM 16GB 稍嚴，處理自體比開始前磁碟讀取更長。記憶體推奨多

## 💻 安裝方法

### 必要條件

- Windows 10/11（Linux/Mac也可能支援基本功能）
- NVIDIA GPU（建議RTX 30/40系列，最低8GB VRAM）
- CUDA Toolkit 12.6
- Python 3.10.x
- 最新版NVIDIA GPU驅動程式

※ Linux支援在v1.2得到加強，並添加了開啟功能，但部分功能可能有限制。

### 步驟

#### 安裝官方套件

首先需要安裝原始的FramePack。

1. 從[官方FramePack](https://github.com/lllyasviel/FramePack?tab=readme-ov-file#installation)下載Windows一鍵安裝包。
   點擊「Click Here to Download One-Click Package (CUDA 12.6 + Pytorch 2.6)」。

2. 解壓下載的套件，執行`update.bat`後再執行`run.bat`啟動。
   執行`update.bat`很重要。如果不執行，可能會使用包含潛在錯誤的舊版本。

3. 首次啟動時會自動下載所需模型（約30GB）。
   如果已有下載好的模型，請放置在`framepack\webui\hf_download`資料夾中。

4. 此時可以運行，但如果未安裝加速庫（Xformers、Flash Attn、Sage Attn），處理速度會較慢。
   ```
   Currently enabled native sdp backends: ['flash', 'math', 'mem_efficient', 'cudnn']
   Xformers is not installed!
   Flash Attn is not installed!
   Sage Attn is not installed!
   ```

   處理時間差異：※RAM:32GB、RXT4060Ti(16GB)的情況
   - 未安裝加速庫時：約4分46秒/25步驟
   - 安裝加速庫時：約3分17秒〜3分25秒/25步驟

5. 要安裝加速庫，請從[Issue #138](https://github.com/lllyasviel/FramePack/issues/138)下載`package_installer.zip`，解壓後在根目錄執行`package_installer.bat`（在命令提示字元中按Enter）。

6. 重新啟動確認加速庫是否安裝成功：
   ```
   Currently enabled native sdp backends: ['flash', 'math', 'mem_efficient', 'cudnn']
   Xformers is installed!
   Flash Attn is not installed!
   Sage Attn is installed!
   ```
   作者執行時，Flash Attn未安裝。
   注意：即使未安裝Flash Attn，對處理速度影響很小。測試結果顯示，Flash Attn的有無造成的速度差異很小，「Flash Attn is not installed!」狀態下約3分17秒/25步驟，與全部安裝時（約3分25秒/25步驟）幾乎相同。
   Xformers是否安裝影響最大。

#### 安裝FramePack-eichi

1. 將`run_endframe_ichi.bat`放在FramePack的根目錄。
2. 將以下檔案和資料夾放在`webui`資料夾中：
   - `endframe_ichi.py` - 主應用程式檔案
   - `eichi_utils` 資料夾 - 工具模組（v1.3.1改進，v1.6.2新增UI相關模組）
     - `__init__.py`
     - `frame_calculator.py` - 幀大小計算模組
     - `keyframe_handler.py` - 關鍵幀處理模組
     - `keyframe_handler_extended.py` - 關鍵幀處理模組
     - `preset_manager.py` - 預設管理模組
     - `settings_manager.py` - 設定管理模組
     - `ui_styles.py` - UI樣式定義模組（v1.6.2新增）
     - `video_mode_settings.py` - 影片模式設定模組
   - `lora_utils` 資料夾 - LoRA相關模組（v1.3新增，v1.3.2改進）
     - `__init__.py`
     - `dynamic_swap_lora.py` - LoRA管理模組（已廢棄掛鉤方式，僅支援直接應用方式）
     - `lora_loader.py` - LoRA載入模組
     - `lora_check_helper.py` - LoRA應用狀態確認模組（v1.3.2新增）

3. 執行`run_endframe_ichi.bat`啟動FramePack-eichi的WebUI。

#### Linux安裝方法

在Linux上，可以按照以下步驟執行：

1. 下載並放置上述必要檔案和資料夾。
2. 在終端機中執行以下命令：
   ```bash
   python endframe_ichi.py
   ```

## 🚀 使用方法

### 基本動畫生成　※既存功能

1. **上傳圖片**: 「Image」 框中上傳圖片
2. **輸入提示詞**: 輸入角色動作提示詞
3. **設定調整**: 調整動畫長度和種子值
4. **開始生成**: 「開始生成」 按鈕點擊

### 高級設定

- **生成模式選擇**:　※獨自功能
  - **通常模式**: 一般動畫生成
  - **循環模式**: 最終幀返回最初幀的循環動畫

- **所有邊距選擇**:　※v1.4 添加、此值越小1次會動畫越激烈
  - **所有邊距**: 所有區段使用同一邊距值
  - **邊距值**: 0~3 的整數值

- **影片長度設定**：※獨有功能的擴展
  - **1秒**：超短影片（v1.5.1新增）
  - **2秒**：短影片（v1.6.1新增）
  - **3秒**：短影片（v1.6.1新增）
  - **4秒**：短影片（v1.6.1新增）
  - **6秒**：標準短影片
  - **8秒**：較長影片
  - **10(5x2)秒**：5部分×2秒的複合影片
  - **12(4x3)秒**：4部分×3秒的複合影片
  - **16(4x4)秒**：4部分×4秒的複合影片
  - **20(4x5)秒**：4部分×5秒的複合影片

  ※v1.6.1新增2〜4秒的短時間模式，使短影片生成更加靈活。

- **MP4壓縮設定**：※v1.6.2從主分支合併
  - 可在0〜100範圍內設定（0=無壓縮、16=預設值、較高值=高壓縮・低品質）
  - 數值越小品質越高，但檔案大小也越大
  - 如果出現黑畫面，設定為16可能可以解決

- **關鍵幀設定**：※nirvash新增功能
  - **Image**：主要的起始關鍵幀
  - **Final Frame**：最終幀（可選）
  - **區段設定**：可為每個區段設定關鍵幀圖像和提示詞

- **關鍵幀自動複製功能**：※v1.7強化
  - **紅框(區段0)**：自動複製到所有偶數區段(0,2,4,6...)
  - **藍框(區段1)**：自動複製到所有奇數區段(1,3,5,7...)
  - 可透過核取方塊開啟/關閉
  - 這樣只需2個關鍵幀設定即可覆蓋所有區段

- **區段專屬提示詞**：※v1.2新增【測試功能】
  - 可為每個區段設定獨立的提示詞
  - 區段專屬提示詞僅在該區段生成時使用
  - 空白時使用通用提示詞
  - 注意：此功能為測試功能，效果無法保證

- **Hunyuan LoRA設定**：※v1.3新增【開發中】
  - 「使用LoRA」核取方塊：切換LoRA的啟用/停用
  - LoRA檔案選擇：選擇要使用的LoRA檔案
  - 應用強度滑桿：在0.0〜1.0範圍內調整LoRA的影響程度
  - 格式選擇：可選擇HunyuanVideo/Diffusers/Musubi等格式
  - 注意：使用Hunyuan LoRA時，進度條開始前會有讀取等待時間，整體處理時間會變長
  - LoRA種類多樣且樣本數少，請有經驗的使用者嘗試

- **輸出資料夾設定**：※v1.2新增
  - 可指定輸出資料夾名稱
  - 「儲存並開啟輸出資料夾」按鈕可同時儲存設定和開啟資料夾
  - 設定在應用程式重新啟動時也會保留

![FramePack-eichi畫面3](images/framepack_eichi_screenshot3.png)

## 🧠 關鍵幀圖像設定的機制與思路

### 基本關鍵幀圖像的關聯性

**Image（輸入圖像）、Final Frame（最終幀）與關鍵幀圖像的關係**：

1. **優先順序**：
   - 基本上，如果設定了區段專屬的關鍵幀圖像，這些會優先使用
   - 如果區段4（第一個區段）未設定圖像，則使用輸入圖像（Image）生成該部分
   - 如果區段0（最後一個區段）未設定圖像，則使用Final Frame生成該部分

2. **時間序列處理順序**：
   - FramePack具有「從未來到過去」生成的特性
   - 從未來（影片進行）方向思考，順序如下：
     1. Image（輸入圖像） - 整體起點
     2. 區段4的關鍵幀圖像 - 第一個區段的起點
     3. 區段3,2,1的關鍵幀圖像 - 中間區段的起點
     4. 區段0的關鍵幀圖像 - 最後區段的起點
     5. Final Frame（最終幀） - 整體終點

3. **區段內圖像的角色**：
   - 關鍵幀圖像是該區段動作的起點
   - 每個區段基於指定的關鍵幀圖像生成
   - 如果未設定關鍵幀圖像，則使用從其他圖像推測的中間狀態

這種結構使得可以進行細緻的區段控制，實現更自然且連貫的動作。

### v1.7的革新：紅框/藍框關鍵幀系統

v1.7大幅改進了關鍵幀圖像的複製功能，引入了更高效且直覺的系統：

1. **紅框/藍框視覺區分**：
   - **紅框(區段0)**：自動複製到所有偶數區段(0,2,4,6...)
   - **藍框(區段1)**：自動複製到所有奇數區段(1,3,5,7...)

2. **關鍵幀設定效率化**：
   - 僅需2個關鍵幀設定即可覆蓋所有區段
   - 以前需要為每個區段單獨設定，現在透過模式化自動複製大幅提高效率

3. **動態區段數對應**：
   - 根據選擇的影片長度和幀大小精確計算區段數
   - 自動調整複製目標以符合計算出的區段數

4. **核取方塊靈活控制**：
   - 可選擇性地啟用/停用自動複製功能
   - 提供更細緻的控制選項

該系統大大減少了設定關鍵影格所需的工作量，尤其是在製作長影片（超過 10 秒）時。

### FramePack的動作原理

FramePack 最大的特點是其獨特的「從未來到過去」的視訊生成方法。傳統的影片產生 AI 是從第一幀到未來的順序產生幀，因此影片越長，畫質和一致性就越差。

FramePack 首先根據輸入影像產生最終幀，然後反向建立每一幀。這使得即使在長影片中也能保持高畫質和一致性。

### FramePack-eichi的擴充功能

FramePack-eichi透過策略性地配置多個關鍵幀圖像，進一步提升品質：

1. **防止最終區段的劇烈變化**：
   - 原始endframe中僅在最後1秒區段設定圖像時，在最終區段（最初1秒附近）會出現圖像突然變化的問題
   - FramePack-eichi採取了在所有區段都加入關鍵幀圖像的簡單粗暴方法
   - 特別重要的關鍵幀用紅框強調顯示，設定這些圖像後會自動複製
   - 如前所述，FramePack從最終區段開始生成影片，因此區段排列和關鍵幀設定也是從最後開始
   - 在6秒模式下，FramePack可能來不及發揮全力就結束循環，無法到達循環模式的關鍵幀圖像
   - 8秒模式下，圖像的過渡比6秒模式更平緩
   - 無論哪種情況（包括後述的多場景模式），圖像差異越大，動作變化越大，可以生成更流暢的動作

2. **循環功能的最佳化**：
   - 在循環模式下，第一個關鍵幀會自動複製到Final Frame
   - 從v1.5.1開始，一般模式中從輸入圖像的複製處理已停止，僅在循環模式中啟用圖像複製
   - 在關鍵幀圖像1中設定循環的起始姿勢，可以創建流暢的循環影片

3. **區段專屬提示詞設定**：※v1.2新增【測試功能】
   - 為每個區段設定獨特的提示詞，可以在各區段實現不同的動作和表現
   - 例如，可以自然表現「走路」→「坐下」→「揮手」等動作變化
   - 提示詞的影響很微妙，但與關鍵幀圖像結合使用會更有效

4. **短影片模式的添加**：※v1.6.1新增
   - 支援1秒、2秒、3秒、4秒的短影片模式
   - 設定每個模式的節數和最佳化的複製模式
   - 啟用針對短影片表現的專門控制

### 設定提示的技巧

提示設定與關鍵影格影像同樣重要：

1. **提示的基本結構**：
  - 依照主題 → 動作 → 其他元素的順序進行寫作是有效的。
  - 例如：`The character walks gracefully, with clear movements, across the room.`

2. **動畫的指定程度**:
  - 無示範：基本動畫生成
  - 簡易動畫：即使是 `moves back and forth, side to side` 也能產生基本動畫。
  - 工具動效影片：如果您指定諸如 `dances powerfully, with clear movements, full of energy` 等細節，則會產生額外的動效影片。

3. **注意事項**：
  - 使用暗示大動作的詞語，例如“跳舞”，可能會導致動作比你預期的更誇張。
  - 實用提示範例：
    - 穩定的動作：`The character breathes calmly, with subtle body movements.`
    - 中程度的動作：`The character walks forward, gestures with hands, with natural posture.`
    - 複雜的動作：`The character performs dynamic movements with energy and flowing motion.`

4. **提示深層結構（LLAMA 和 CLIP 分離）**:
  - 在 FramePack 內部，提示由兩種不同的模型處理：

  - **LLAMA 模型（限制 256 個 token）**：
    - 負責文本的詳細理解和上下文處理
    - 用於控制影片的整體內容和順序
    - 預計字元數：約 1000-1300 個字元（英文）或 200-400 個字元（日文）
    - 參與控制場景的脈絡和敘事

  - **CLIP 模型（限制 77 個 token）**：
    - 專門用於將圖像與文字關聯的模型
    - 影響視訊畫面特定視覺特徵的生成
    - 預計字元數：約 300-400 個字元（英文）或 50-150 個字元（日文）
    - 參與控制風格、主題和視覺屬性

5. **撰寫有效提示的策略**：
  - **前 300-400 個字元（英文）/50-150 個字元（日文）**：
    - LLAMA 和 CLIP 均涉及的重要“視覺部分”。
    - 包括主要視覺元素、風格、主題和整體基調。
    - 範例：`A young woman with long flowing hair, cinematic lighting, detailed facial features, soft expressions, gentle movements`

  - **後者 600-900 個字元（英語）/150-250 個字元（日文）**：
    - 僅由 LLAMA 處理的“敘事部分”。
    - 您可以在此處撰寫動作細節、場景背景和序列訊息。
    - 例如：`The camera slowly pans from left to right. The woman gradually turns her head, her expressions changing from neutral to a slight smile. There is a sense of emotional buildup as if emotional music is playing in the background.`

6. **如何使用特定章節提示**：※新增於 v1.2 [測試實作]
  - 特定章節提示應簡短，並專注於該章節的重要操作
  - 清晰、具體的指示比長句更有效
  - 例：第 1 節“行走動作”，第 2 節“坐下動作”，第 3 節“揮手動作”
  - 注意：章節提示的效果微妙，務必將其與圖片設定結合

7. **LoRA 使用**：※新版本 v1.3 [測量測試工作]
  - LoRA 的選擇和呈現組合可透過特定樣式或表達方式進行增強。
  - LoRA 效果傳輸強度調節（0.1-0.3 為細微，0.5-0.8 為顯著）
  - 呈現文字與 LoRA 的選擇和匹配，達到最佳效果
  - v1.6 版本採用統一的高 VRAM 模式與低 VRAM 模式應用方法，提升一致性與穩定性

### 選擇有效的差異影像

FramePack 產生的視訊品質很大程度上取決於關鍵影格影像的選擇。選擇理想差異影像的重點：

1. **最佳差異等級**：
   - **差異過小**：使用幾乎相同的影像（即所謂的「智慧差異」）幾乎不會產生任何運動。
   - **差異過大**：使用完全不相關的影像將無法產生自然的運動。
   - **理想差異**：最佳差異是AI能夠找到相關變化的差異，例如同一角色的不同姿勢。

2. **保持相關性**：
  - 例如，簡單地水平翻轉影像會被 AI 識別為完全不同的影像，並且不會產生自然的移動。
  - 臉部方向、手部位置、身體姿勢等的變化是理想的差異元素。
  - 盡可能保持背景和服裝的一致性，使 AI 能夠專注於角色的動作。
  - 諷刺的是，圖像生成 AI 根據相似提示創建的角色的波動，正是理想的差異元素之一。

3. **理想的差異影像特徵**：
  - 同一角色，姿勢略有變化
  - 面部表情細微變化（例如，從面無表情到微笑。然而，如果面部位置不變，則動作較弱）
  - 姿勢變化伴隨手和手臂的自然運動
  - 頭部方向逐漸變化

4. **實驗方法**：
  - 選擇差異圖像更具藝術性而非科學性，因此反覆試驗至關重要。
  - 從相似姿勢的差異開始，逐步調整差異大小是有效的。
  - 記錄成功的組合，並將它們應用到未來的作品中。

5. ** 影像生成 AI 與不同影像組合 **：
  - 當不存在理想的差異影像時，可使用影像產生 AI 產生相同角度的不同姿勢。
  - 當前句子中指定的姿勢變化將導致迴避程度發生變化，因此實際的自然動作也會發生變化。

這種結構化的方法有助於我們充分利用兩種模型的優勢並產生更具表現力的影片。

### EndFrame 影響與 All Padding 的區別，基礎知識與實踐

#### 兩個函數的根本區別

FramePack-eichi 有兩個重要的函數用來控制影片的動態。 “EndFrame 影響調整”和“All Padding”。雖然乍看之下這兩個函數似乎很相似，但它們的工作原理和效果卻完全不同。

##### 1. EndFrame 影響調整（v1.3 版本引入）

**影響**：這會直接改變**最終幀**本身的強度。

**技術機制**：
- 將最後一幀的潛在表示與指定值精確相乘
- 程式碼實作為 `modified_end_frame_latent = end_frame_latent * end_frame_strength`
- 值範圍從 0.01 到 1.00，預設值為 1.00（無變化）

**效果**：
- 將數值從 1.0 降低到 0.5，將使最後一幀的「整體」影響精確減半
- 值為 0.3，將使最後一格的「整體」影響精確減半 30%
- 減少最後一格的直接影響，以便第一幀（輸入影像）的特徵更快地顯現

##### 2. 所有填充（v1.4 中引入）

**作用**：這會改變**各部分之間的連接方式**。

**技術機制**：
- 通常情況下，各部分之間的填充值會自動計算為 `[3, 2, 2, 2, 1, 0]`
- 啟用所有填滿後，此值將統一為您指定的單一值（例如 `[1.5, 1.5, 1.5, 1.5, 1.5, 0]`
- 值的範圍為 0.2 到 3.0，標準值為 1.0
- 最後一個部分（第 0 個部分）始終強制為 0

**效果**：
- 較高的值（例如 1.5）會使每個部分更強烈地引用前一個部分，從而導致變化較少。
- 較低的值（例如 0.5）會使每個部分更弱地引用前一個部分，從而導致變化較多。
- 變化量的「分佈」會發生變化，但框架的整體強度不會改變。

#### 類比解釋具體差異
為了使為了更容易理解這些差異，我們將用三個類比來解釋：

**音樂類比**：
- **EndFrame Influence**：這就像調整管弦樂團「主旋律的音量」。 0.5 的音量相當於將整個主旋律的音量減半。
- **All Padding**：它調整「每個樂章之間過渡的平滑度」。值越大，過渡越平滑，值越小，每個樂章之間的變化越突兀。

**烹飪類比**：
- **EndFrame Influence**：這就像調整「主要調味料的用量」。如果將醬汁本身的用量設定為 0.5，食材的原味自然會更濃鬱。
- **All Padding**：它調整在每個烹飪步驟中保留前一道工序風味的程度。數值越高，每個工序的特性就會融合得更緊密，數值越低，每個工序就會擁有各自獨特的風味。

**漸層類比**：
- **結束畫面影響**：這就像在從紅色到藍色的漸變中調整「紅色原色的強度」。紅色強度為 0.5 時，漸層顏色將從淺紅色（接近粉紅色）變為藍色。
- **所有填滿**：使用相同的漸層調整「顏色混合」。值較高時，從紅色到藍色的過渡是漸進且堆疊的，而值較低時，從紅色到紫色再到藍色的過渡是突然的。

#### 補充技術說明

即使在原始碼層面，這兩個函數的操作也完全不同：

```
// 實作 EndFrame 影響調整
// 直接乘以最後一幀本身的潛在表示

if end_frame_strength != 1.0:
    modified_end_frame_latent = end_frame_latent * end_frame_strength
    history_latents[:, :, 0:1, :, :] = modified_end_frame_latent
else:
    history_latents[:, :, 0:1, :, :] = end_frame_latent
```

```
// 實作所有填充
// 使用統一值覆寫各部分之間的填滿數組

if use_all_padding:
    padding_value = round(all_padding_value, 1) # 固定為小數點後一位
    latent_paddings = [padding_value] * total_latent_sections
    # 最後一段強制為 0
    latent_paddings[-1] = 0
else:
    # 正常填充值計算
    latent_paddings = reversed(range(total_latent_sections))
    if total_latent_sections > 4:
        latent_paddings = [3] + [2] * (total_latent_sections - 3) + [1, 0]
```

這樣，EndFrame influence 只是簡單地將最終幀本身的潛在表示相乘，而 All Padding 則執行了一個最佳化過程，用相同的值重寫每個部分之間的填充數組。

#### 組合效果

這兩個參數的工作方式完全不同，因此您可以如下組合它們：

1. **EndFrame Influence 0.5 + Normal Padding**：
  - 最後一格的影響減半
  - 各部位之間的過渡正常
  - 結果：從最後一幀到第一幀的過渡整體更快

2. **EndFrame Influence 1.0 + All Padding 1.5**：
  - 最後一幀的影響正常
  - 各部分之間的過渡更平滑
  - 結果：部分劃分更不明顯，過渡更純粹

3. **EndFrame Influence 0.3 + All Padding 0.5**：
  - 最後一幀的影響大為減弱
  - 各部分變得更獨立，變化量增加
  - 結果：創造出非常活躍的動作和快速的變化

#### EndFrame Influence 和 All Padding 選擇指南

根據場景：

##### 合適的 EndFrame Influence 值

- **差異較大影像**：0.3-0.6（實現漸層）
- **差異中等**：0.5-0.8（過渡均衡）
- **差異較小**：0.8-1.0（接近標準效果）
- **臉部表情變化**：0.7-0.8（過渡自然）
- **肢體和手部動作較大**：0.3-0.5（中間畫面較自然）

##### 所有 padding 的適當值

- **平滑過渡**：1.5-2.0（純過渡，片段邊界不明顯）
- **標準動作**：1.0（過渡均衡）
- **主動動作**：0.5-0.7（每個片段變化較大）
- **極端動作**： 0.2-0.4（產生非常活躍且難以預測的運動）

##### 實用技巧

- **Influence 0.5 + 所有填充 0.5**：如果您想要更動態的運動
- **Influence 0.3 + 短模式**：用於創建快速變化的循環動畫
- **Influence 0.8 + 長模式**：用於表達緩慢變化的平緩運動
- **非常低的影響 (0.01-0.1)**：思維模式的改變，幾乎忽略了最後一幀，而將第一幀作為“目標”
- **較高的所有填充值（2.0 或更高）+ Influence 0.5**：降低最後一幀的影響，同時不突出片段邊界

##### 調整過程和實驗。環境

- 先使用預設值 (1.0) 生成
- 如果運動不自然，請嘗試將值降低到 0.7 左右
- 如果需要進一步調整，請嘗試使用 0.5、0.3 等值線。
- 僅更改相同影像對的影響度以進行比較和驗證也是有效的。
- 為了探索結果，請嘗試更改所有填充值，這將使您更接近指定的運動效果。

EndFrame 影響度和填充值之間的關係就像烹飪中「開始時使用的調味料量」和「每個過程中參考上一步的量」。透過適當結合兩者，您可以實現理想的運動效果。


## 🛠️ 配置資訊

### 基本設定（Windows 系統為 bat 檔案）
  - **連接埠設定**：`--port` 參數（預設值：8001）
    - WebUI 使用的連接埠號碼
    - 如果與其他應用程式衝突，請更改

  - **伺服器位址**：`--server` 參數（預設值：'127.0.0.1'）
    - 如果在本地網路內訪問，請更改為 `0.0.0.0`

  - **自動啟動瀏覽器**：`--inbrowser` 選項
    - 啟動時自動開啟瀏覽器

### 性能設定
- **GPU 記憶體預留設定**：`gpu_memory_preservation` 滑桿（預設值：9GB）※現有功能
  - 值越小 = 顯示佔用越多 = 處理速度越快
  - 值越大 = 顯示佔用越少 = 運作更穩定
  - 運作原理：數值越小，為 Transformer 模型釋放的記憶體越多
  - 計算方法：工具可用的記憶體大小（保證至少 6GB）等於工具可用的記憶體大小（保證至少 6GB）
  - 範例：對於 16GB 顯示記憶體，如果加上餘裕並將其設為 14GB，則將使用“14-(10-6)=10GB”
  - 如果將其設為下限 6GB，則將使用“14-(6-6)=14GB”，這幾乎是最大值（1 個部分的處理時間會減少約 10 秒，並且存在記憶體交換的風險）
  - 建議值：
    - 8GB 記憶體：7-8GB
    - 12GB 記憶體：6-8GB
    - 16GB 或以上：約 6GB
  - 注意：如果您同時執行其他應用程序，請增加此值。
  - 此工具會預留 3GB 內存，以便其他影像產生工具在背景運行，從而防止內存交換。
  - 如果您使用的是 LoRA，建議您預留更多記憶體。

- **高記憶體模式**：自動偵測（v1.5.1：60GB 或以上，v1.6：100GB 或以上可用記憶體）*功能改進
  - 啟用後：模型始終保留在 GPU 上，減少記憶體傳輸開銷
  - 效果：處理速度提升高達 20%
  - 在 v1.6 中，標準值已提高，現在大多數環境中都使用低 VRAM 模式
  - 低 VRAM 模式採用與高 VRAM 模式相同的直接應用方法，提高了功能的一致性

### 生成設定
- **幀大小設定**：`frame_size` 下拉選單（預設值：1 秒）※v1.5 新增
  - 0.5 秒：產生 0.5 秒的畫面。片段數量和處理時間幾乎會翻倍。
  - 在 All-Budding 0 模式下，您可以透過為每個畫面影像添加差異來創建更激烈的運動。
  - 1 秒：產生 1 秒的畫面。

- **步數**：`steps` 滑桿（預設值：25）※現有功能
  - 增加該值可以提高質量，但處理時間也會相應增加。
  - 建議範圍：20-30（20 通常可以獲得幾乎相同的品質）
  - 15 或更低：品質明顯下降

- **TeaCache**：`use_teacache` 複選框（預設：啟用）※現有功能
  - 啟用：處理速度提升約 15-20%
  - 副作用：手和指尖等精細細節可能會略有下降
  - 用途：建議用於一般視訊生成，當精細細節很重要時停用

- **隨機種子值**：`seed` 輸入一個值或勾選「使用隨機種子」複選框 ※由 nirvash 新增
  - 相同的種子值 = 可重複的結果
  - 隨機種子：每次產生不同的動作
  - 注意：即使種子相同，如果提示或影像發生變化，結果也會發生變化

- **精煉 CFG 比例**：`gs` 滑桿（預設值：10.0）※現有功能
  - 精煉引導比例值
  - 值越小，移動越自由（與提示偏差越大）
  - 值越大，移動越忠實於提示（移動可能會受到限制）
  - 建議：保留預設值（進階使用者可以更改）

- **MP4 壓縮設定**：`mp4_crf` 滑桿（預設值：16）*與 v1.6.2 中的原版合併
  - 範圍：0-100（0=無壓縮，100=最大壓縮）
  - 數字越小，影片品質越高，但檔案大小也越大
  - 數字越大，壓縮率越高，檔案大小越小，但影像品質越低
  - 如果您遇到黑屏問題，請將其設為 16 以解決問題
  - 用途：低值 (0-10) 用於存儲，中等值 (16-30) 用於網路共享

### LoRA 設定（v1.3 新增，v1.6 改進）
- **使用 LoRA**：`use_lora` 複選框（預設為停用）
  - 啟用：使用 LoRA 檔案自訂模型
  - 使用 LoRA 時，計數器啟動前的等待時間可能會更長。

- **LoRA 檔案**：`lora_file` 檔案選擇元件
  - 指定要使用的 LoRA 文件
  - 支援格式：僅 FramePack 格式（已在 v1.3.2 版本中驗證）

- **LoRA 強度**：`lora_strength` 滑桿（預設值：0.8）
  - 範圍：0.0 至 1.0
  - 值較小：影響較小
  - 值較大：影響較大
  - 最佳值因 LoRA 檔案而異

- **LoRA 格式**：單選按鈕
  - HunyuanVideo：適用於 Hunyuan Video 的 LoRA 格式
  - Diffusers：Diffusers 格式的 LoRA

### 幀設置
- **影片長度**：單選按鈕 + `total_second_length` 滑桿 *獨特功能擴展
  - **1 秒**：超短影片（約 30 幀 @ 30fps） - v1.5.1 版本新增
  - **2 秒**：短片（約 60 幀 @ 30fps） - v1.6.1 版本新增
  - **3 秒**：短片（約 90 幀 @ 30fps） - v1.6.1 版本新增
  - **4 秒**：短片（約 120 幀 @ 30fps） - v1.6.1 版本新增
  - **6 秒**：標準模式（約 180 幀 @ 30fps）
  - **8 秒**：擴展模式（約 240 幀 @ 30fps）
  - **10(5x2) 秒**：複合視訊（約 300-324 幀 @ 30fps）
  - **12(4x3)秒**：複合視訊（約 360 幀 @ 30fps）
  - **16(4x4)秒**：複合視訊（約 480 幀 @ 30fps）
  - **20(4x5)秒**：複合視訊（約 600-624 幀 @ 30fps）

- **自動關鍵影格複製**：`enable_keyframe_copy` 複選框（預設：停用 - 在 v1.5.1 中變更）※獨特功能
  - 啟用：關鍵影格影像自動複製到其他部分
  - 停用：每個關鍵影格必須單獨設置
  - 用途：設計複雜動作的進階使用者可以停用此功能

### 輸出設定
- **輸出資料夾**：輸出資料夾設定欄位（預設值：`outputs`）※v1.2 新增
  - 用於保存生成的影片和圖片的目標位置
  - 您可以在輸入欄位中直接輸入資料夾名稱
  - 您可以使用「開啟已儲存和輸出資料夾」按鈕開啟資料夾
  - 設定以 JSON 格式儲存，即使重新啟動後仍會保留

- **儲存章節靜態影像**：勾選 `save_section_frames` 複選框（預設為停用）※nirvash 新增的功能
  - 啟用：每個章節的最後一幀將儲存為靜態影像
  - 用途：當您想檢查每個章節之間的連接時非常有用

- **儲存片段影片**：勾選 `keep_section_videos` 複選框（預設為停用）※獨特功能
  - 啟用：每個片段的影片檔案都會被保留，如果您點擊「結束」按鈕，影片檔案也會保留。
  - 停用：僅儲存最終完成的影片（中間檔案會被刪除），因此請小心不要將其放入回收站。
  - 用途：當您想單獨查看每個片段的進度時非常有用。

### 提示符號管理
  - **儲存預設**：「儲存」按鈕
    - 使用名稱儲存目前提示符
    - 使用空名稱儲存，將其設定為啟動時的預設提示符

  - **套用預設**：「套用」按鈕
    - 將所選預設的提示符號套用到目前生成設定

  - **預設管理**：
    - 刪除：刪除不需要的預設（預設預設無法刪除）
    - 清除：清除編輯字段

## 🔧 故障排除

### 關於 h11 錯誤

首次啟動工具並匯入影像時，您可能會遇到許多錯誤，例如：
※錯誤將顯示在控制台中，但圖像不會顯示在 GUI 中。

![FramePack-eichi錯誤畫面1](images/framepack_eichi_error_screenshot1.png)
```
ERROR:    Exception in ASGI application
Traceback (most recent call last):
  File "C:\xxx\xxx\framepack\system\python\lib\site-packages\uvicorn\protocols\http\h11_impl.py", line 404, in run_asgi
```
當處理 HTTP 回應時出現問題時，會顯示此錯誤。
如上所述，這通常發生在啟動過程的早期，即 Gradio 尚未完成啟動時。

解決方案：
  1. 刪除有「X」按鈕的圖片，然後重新嘗試上傳。
  2. 如果上傳同一文件重複失敗：
    - 完全停止 Python 進程，然後重新啟動應用程式
    - 重新啟動電腦，然後重新啟動應用程式

如果錯誤仍然存在，請嘗試其他圖片檔案或減小圖片大小。

### 記憶體不足錯誤

在 Windows 系統中，如果顯示「CUDA out of memory」或「RuntimeError: CUDA error」，請按照以下步驟操作：

1. `gpu_memory_preservation` 的值設定為 12-16GB
2. 關閉其他使用 GPU 的應用程式
3. 重新啟動應用程式
4. 降低圖片解析度（640x640 附近）

### LoRA相關的問題（v1.3以降）

在 Windows 系統中，如果顯示「LoRA is disabled because there is no target for blending」，請按照以下步驟操作：

1. 別的LoRA文件試用
2. LoRA形式的選択確認
3. LoRA強度調整至 0.5-0.8
4. 確認提示符與LoRA內容一致

在 v1.6 版本中，LoRA 的應用方法已統一，現在可以像在高 VRAM 模式下一樣在低 VRAM 模式下直接套用 LoRA。這提高了穩定性，但可能會增加 VRAM 佔用率。

### 影片顯示問題

產生的影片在某些瀏覽器（尤其是 Firefox）和 macOS 上有無法顯示的問題：

- 問題：影片在 Gradio UI 中不顯示，Windows 系統上不顯示縮圖，部分播放器無法播放
- 原因：`\framepack\webui\diffusers_helper\utils.py` 中的視訊編解碼器設定有問題

此問題需要在原始程式碼庫 (lllyasviel/FramePack) 中修復。 FramePack-eichi 將盡量避免修改原始原始碼，並等待原始原始碼修復。

臨時解決方法：
1. 使用相容性較高的播放器（例如 VLC）播放產生的影片文件
2. 在其他影片編輯軟體中開啟並重新儲存
3. 如果您具備技術知識，可以手動套用以下修復程序：
    ```python
    # \framepack\webui\diffusers_helper\utils.py 的對應部分
    # 修改前
    torchvision.io.write_video(output_filename, x, fps=fps, video_codec='libx264', options={'crf': '0'})
    # 修改後
    torchvision.io.write_video(output_filename, x, fps=fps, video_codec='libx264', options={'crf': '17', 'pix_fmt': 'yuv420p'})
    ```

※該問題已在原始儲存庫中作為拉取請求#49提出，預計將在未來的更新中解決。

## 📝 更新日誌

### 2025-04-28：版本 1.7.0
- **關鍵影格影像複製功能重大改進**：
  - 引入紅/藍幀視覺區分
  - **紅幀（第 0 幀）** ⇒ 自動複製到所有偶數幀（0、2、4、6…）
  - **藍幀（第 1 幀）** ⇒ 自動複製到所有奇數幀（1、3、5、7…）
  - 提升動態影格數計算精準度，可依所選影片時間精準調整複製範圍
  - 使用者可以根據需要開啟/關閉複製功能
- **提升複製過程安全性**：
  - 強化幀邊界檢查，防止複製到無效位置
  - 詳細的日誌輸出使複製操作更易於追蹤

### 2025-04-27：版本 1.6.2
- **新增 MP4 壓縮設定**：*與原版合併
  - 可調式影片檔案大小與畫質之間的平衡
  - 可在範圍為 0 到 100（0 = 無壓縮，16 = 默認，更高值 = 高壓縮率，低質量）
  - 提供最佳設定以解決黑屏問題
- **提升程式碼品質**：
  - 將 UI 樣式定義分離為 `ui_styles.py`，以提高可維護性和可讀性
  - 透過專注於管理 CSS 樣式，提高 UI 一致性
- **微調幀大小計算**：
  - 提升 0.5 秒模式下的運算精度（使用 `latent_window_size=4.5`）
  - 提升分段數和視訊時長的計算精度，使視訊生成更穩定

### 2025-04-26：版本 1.6.1
- **擴展短視訊模式**：
  - 2 秒模式：60 幀（2 秒 x 30 FPS），2 個分段，無需複製
  - 3 秒模式：90 幀（3 秒 x 30 FPS）， 3 個部分，將關鍵影格 0 複製到 1
  - 4 秒模式：120 幀（4 秒 x 30 FPS），4 個部分，將關鍵影格 0 複製到 1、2
- **回歸 v1.5.1 的基本結構**：
  - 保留原有模式名稱符號（附括號）
  - 恢復關鍵影格指南 HTML
  - 保留原有函數結構和處理方式

### 2025-04-26：版本 1.6.0 *已否決版本
- **UI/UX 改進**：
  - 將部分設定拆分為折疊面板，以便僅在必要時展開
  - 簡化視訊模式名稱（例如「10（5x2）秒」→「10秒」）
  - 移除關鍵影格高亮
  - 將不必要的功能（結束影格影響調整、關鍵影格自動複製功能）變更為內部設置
- **技術改進**：
  - 更改了 VRAM 管理的標準值（60GB → 100GB）
  - 改進了分段計算邏輯（增加了直接從秒數計算的功能）
  - 提高了幀數和分段數的一致性（確保與顯示秒數一致）
  - 優化了調試輸出

### 2025-04-25：版本 1.5.1
- **新增「1 秒」短影片產生模式**：
- 支援 1 秒（約 30 幀，30fps）
- **更改預設影片時長**：
- 將預設值從“6 秒”更改為“1 秒”
- **優化輸入影像複製操作**：
- 在普通模式下停止從輸入影像複製
- 循環模式下啟用僅複製到最後一個影像
- **更改關鍵影格自動複製功能的預設值**：
- 預設關閉，以便更精細地控制
- 必要時可開啟自動複製功能
- **提升影像處理穩定性**：
- 改進了按下「開始」按鈕時重新獲取影像的正確方法
- 新增了預覽影像的明確清除流程

### 2025-04-24：版本 1.5.0
- **新增幀大小設定**：
- 可在 0.5 秒模式和 1 秒模式之間切換
- 根據幀大小動態調整 latent_window_size

### 2025-04-24：版本 1.4.0
- **新增所有填滿功能**：
- 所有部分使用相同的填充值
- 此值越小，單次會話中的運動越劇烈。

### 2025-04-24：版本 1.3.3
- **重新審視 LoRA 應用功能**：
- 直接 LoRA 載入模式已被否決，因為它需要金鑰匹配才能設定參數。統一為 DynamicSwap，並等待後續情況。
- 實現了獲取參數數量的日誌顯示。

### 2025-04-24：版本 1.3.2
- **統一 LoRA 應用功能**：
- 統一在低 VRAM 模式下直接套用 LoRA（DynamicSwap）的方式，與在高 VRAM 模式下相同。
- 廢除了 hook 方法，僅支援更穩定的直接應用方式。
- 改進了內部實現，同時保持了介面的兼容性。
- **增強了調試和驗證功能**：
- 新增了用於檢查 LoRA 應用程式狀態的專用實用程式 (lora_check_helper.py)
- 提供詳細的日誌輸出和偵錯資訊。

### 2025-04-24：版本 1.3.1
- **程式碼庫重構**：將程式碼組織成多個模組，以提高可維護性和可擴展性
- `eichi_utils`：管理關鍵影格處理、設定管理、預設管理和視訊模式設定
- `lora_utils`：聚合 LoRA 相關函數

### 2025-04-23：版本 1.3
- **[研究中] 新增混元 LoRA 支援**：自訂模型並新增自訂表情
- **[測試實作] 新增 EndFrame 影響度設定**：最終影格的影響度可在 0.01 至 1.00 之間調整（nirvash 已知）

### 2025-04-23：版本 1.2
- **新增「20 (4x5) 秒」模式**：支援產生包含 5 個部分的長視頻
- **新增每個部分的提示功能**：允許為每個部分設定單獨的提示 [測試實作]
- **增強輸出資料夾管理功能**：支援指定輸出資料夾和獨立於作業系統的開啟方式
- **改進設定檔管理**：使用基於 JSON 的設定檔持久化設定
- **增強跨平台支援**：改進了在 Windows 以外環境下的操作

### 2025-04-22：版本 1.1
- **新增「16（4x4）秒」模式**：支援由 4 個部分組成的長視頻
- **改進了生成過程中的進度顯示**：現在會顯示部分資訊（例如「部分：3/15」），讓您更容易了解進度，尤其是在生成長影片時
- **設定檔結構**：視訊模式設定現在被拆分到單獨的檔案中，提高了可擴展性

### 2025-04-21：首次發布
- 優化提示管理功能
- 新增關鍵影格引導功能

## 🤝 謝辞

本項目基於以下項目的貢獻：

- [lllyasviel/FramePack](https://github.com/lllyasviel/FramePack) - 感謝原作者 lllyasviel 的精湛技術與創新
- [nirvash/FramePack](https://github.com/nirvash/FramePack) - 感謝 nirvash 的開創性改進和擴展

## 📄 許可證

本項目遵循 [Apache 許可證 2.0](LICENSE) 發布。這與原 FramePack 專案的授權一致。

---

**FramePack-eichi** - 端幀圖片連結口
旨在實現更直覺、更靈活的影片生成